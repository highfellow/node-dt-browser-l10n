{
  "name": "asyncxml",
  "description": "async xml builder and generator",
  "version": "0.4.7",
  "homepage": "https://github.com/dodo/node-asyncxml",
  "author": {
    "name": "dodo",
    "url": "https://github.com/dodo"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/dodo/node-asyncxml.git"
  },
  "main": "asyncxml.js",
  "engines": {
    "node": ">= 0.4.x"
  },
  "keywords": [
    "async",
    "xml",
    "generation",
    "stream",
    "browser"
  ],
  "scripts": {
    "test": "cake build && nodeunit test",
    "prepublish": "cake build"
  },
  "devDependencies": {
    "coffee-script": ">= 1.1.2",
    "muffin": ">= 0.2.6",
    "browserify": "1.6.1",
    "scopify": ">= 0.1.0",
    "dt-stream": ">= 0.1.1",
    "nodeunit": ">= 0.7.4"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/dodo/node-asyncxml/raw/master/LICENSE"
    }
  ],
  "readme": "\n# [async XML Generator](https://github.com/dodo/node-asyncxml)\n\n> performance? foock it! i'm faster than that.\n\nasync xml builder and generator\n\nnukular engine of [Δt](http://dodo.github.com/node-dynamictemplate/)\n\nRuns on server and browser side (same code).\n\n## install\n\n    npm install asyncxml\n\n## usage\n\n```javascript\nasyncxml = require('asyncxml')\nxml = new asyncxml.Builder({pretty:true})\nxml.on('data', function (chunk) {\n    console.log(chunk);\n})\n// build some xml\nxml.tag(\"xml\", {version:\"1.0\"})\n        .tag(\"list\")\n            .tag(\"entry\", function () {\n                this.attr('id', 1)\n            }).up()\n            .tag(\"entry\", {id:2}, \"foo\").up()\n        .up()\n    .up()\n.end()\n```\n\n```coffeescript\n# this would result in the same xml\nxml.tag \"xml\", version:\"1.0\", ->\n    @$tag \"list\", ->\n        @$tag \"entry\", ->\n            @attr('id', 1)\n        @$tag \"entry\", id:2, \"foo\"\n    @up().end()\n```\n\n```xml\n<!-- stdout -->\n<xml version=\"1.0\">\n  <list>\n    <entry id=1/>\n    <entry id=2>\n    foo\n    </entry>\n  </list>\n</xml>\n\n```\n\n## api\n\n### Builder([opts])\n\n```javascript\nxml = new asyncxml.Builder({pretty:true})\n```\n * `opts.pretty` switch to toggle pretty printing of the xml output\n * `opts.level` start indention level of xml (starting with `-1`) when pretty is on\n\nUse this to build and grow a XML forest.\n\nThe Builder provides a single environment for many tags and an API for Adapters to interact with the tag events.\n\n#### xml.tag(name, [attrs, [children, [opts]]])\n\n```javascript\ntag.tag(\"xml\", {version:\"1.0\"}, function() { … })\n```\nSame as `Tag::tag`.\n\n\n#### xml.$tag(name, [attrs, [children, [opts]]])\n\n```javascript\ntag.$tag(\"xml\", {version:\"1.0\"}, function() { … })\n```\nSame as `Tag::$tag`.\n\n\n#### xml.show()\n\n```javascript\nxml.show()\n```\nSame as `Tag::show`.\n\n\n#### xml.hide()\n\n```javascript\nxml.hide()\n```\nSame as `Tag::hide`.\n\n\n#### xml.remove([opts])\n\n```javascript\nxml.remove({soft:true})\n```\nSame as `Tag::remove`.\n\n\n#### xml.ready(callback)\n\n```javascript\nxml.ready(function () {\n  console.log(\"builder is done.\")\n})\n```\nInstead of `Tag::ready` it waits for the `end` event,\n\n\n#### xml.end()\n\n```javascript\nxml.end()\n```\nSame as `Tag::end` but without a `close` event.\n\n\n#### xml.register(type, checkfn)\n\n```javascript\nxml.register('new', function (parent, tag, next) {\n    // this gets called _before_ every new tag gets announced ('new' and 'add' event)\n    next(tag) // call next with the new tag to approve that the new tag can be announced\n})\nxml.register('end', function (tag, next) {\n    // this gets called _before_ every gets closed\n    next(tag) // call next with the closing tag to approve that the tag can be closed\n})\n```\nThis is a plugin API method.\n\nThere are only 2 types: `[\"new\", \"end\"]`.\n\nThe `checkfn` function of type `new` must get 3 parameters: `(parent, tag, next)`.\n\nThe `checkfn` function of type `end` must get 2 parameters: `(tag, next)`.\n\nThe [Δt Compiler](http://dodo.github.com/node-dt-compiler/) uses this API to create new tags before others.\n\n\n#### xml.approve(type, parent, tag, callback)\n\nThis is an internal API method to invoke a `checkfn` list registered with `Builder::register` by plugins.\n\n\n#### xml.query(type, tag, key)\n\n```javascript\ntag.text()\ntag.attr('id')\ntag.add(adapter_specific_object)\n```\nThis is a adapter API method.\n\nEvery time a text, an attribute or a tag is requested the tag will ask the builder for the values. A adapter has now the opportunity to override the `query` method of the builder instance to provide a specialised query method.\n\nThe [jQuery Adapter](https://github.com/dodo/node-dt-jquery) for example uses it to provide the values right out of the DOM (eg for type text it returns the value of [jQuery.text](http://api.jquery.com/text/)).\n\n\n---\n\n### Tag(name, [attrs, [children, [opts]]])\n\n```javascript\ntag = new asyncxml.Tag(\"xml\", {version:\"1.0\"}, function() { … }, opts)\n```\n * `name` the [nodeName](https://developer.mozilla.org/en/DOM:element.nodeName)\n * `attrs` an object that contains all tag attributes\n * `children` a function representing the children scope of the tag (see `Tag::children` for more)\n * `opts` some internal options\n\nNormally you don't need to instantiate this, because you should use `Tag::tag` and `Builder::tag` instead.\n\n\n#### tag.tag(name, [attrs, [children, [opts]]])\n\n```javascript\ntag.tag(\"name\", {attrs:null}, function () { … })\n// these work as well:\ntag.tag(\"name\", {attrs:null}, \"content\")\ntag.tag(\"name\", function () {…})\ntag.tag(\"name\", \"content\")\n```\nSame api as `Tag`.\n__info__ tag is not closed.\n\nEmits a `new` and `add` Event.\n\n\n#### tag.$tag(name, [attrs, [children, [opts]]])\n\n```javascript\ntag.$tag(\"sync\", function() { … })\n```\nSame api as `Tag`, with one difference: `tag.end()` is called right after the children scope (even when no children scope is applied).\n\nEmits a `new`, `add` and `end` Event (end is emitted after the children scope).\n\n\n#### tag.toString()\n\n```javascript\ntag.$tag(\"tag\", \"content\").toString()\n(new a.Tag(\"tag\", \"content\")).tag(\"troll\").up().end().toString()\n// both => '<tag>content</tag>'\n```\nThis returns the String representation of the tag when its closed.\n\nIt only contains text content, no children tags, because tags are garbage collected when their not in use anymore.\n\n\n#### tag.children(childrenscope)\n\n```javascript\ntag.children(function () {\n    this.attr({id:2})\n    this.$tag(\"quote\", \"trololo\") // same as this.$tag(\"quote\").children(\"trololo\")\n})\ntag.children(\"content\") // same as tag.text(\"content\")\n```\nThis applies a children scope on a tag.\n\nThe tag instance directly accessible via `this`.\n\nThe children parameter of `Tag::tag` is passed to this method.\n\nEmits whatever event is emitted inside the children scope (of course).\n\n\n#### tag.up([opts])\n\n```javascript\ntag.up()\ntag.up({end:false}) // don't close tag\n```\nUseful for chaining, because it returns the parent tag.\n\nIt closes the tag by default unless `opts.end` is set to false.\n\nCan emit an `end` Event.\n\n\n#### tag.add(newtag)\n\n```javascript\nother = new asyncxml.Tag(\"other\")\ntag.add(other)\n```\nAppend a new Tag.\n\nAdapter specific objects can be passed too.\n\nFor example if you use the [jQuery Adapter](https://github.com/dodo/node-dt-jquery) you can pass a jQuery Object as parameter.\n\nEmits an `add` Event.\n\n\n#### tag.replace(newtag)\n\n```javascript\nother = new asyncxml.Tag(\"other\")\ntag.replace(other)\n```\nReplace a tag with another one.\n\n__todo__ merge tag instances on data model level\n\nEmits a `replace` Event.\n\n\n#### tag.remove()\n\n```javascript\ntag.remove()\n```\nRemove a tag immediately.\nThe tag gets automatically closed.\n\nEmits a `remove` Event.\n\n\n#### tag.attr([key, [value]])\n\n```javascript\ntag.attr() // results in an js object containing all tag attributes\ntag.attr(\"id\") // results in the value of attribute \"id\"\ntag.attr(\"id\", 3) // set attribute \"id\" to 3 and returns the tag instance for chaining\ntag.attr({id:4}) // set many attributes at once\n```\nSet or Get tag attributes.\n\nWhen using an adapter getting an attribute results in a value provided by the adapter.\n\nWhen getting a value the results can be interpreted as follow:\n\n* `undefined` the tag doesn't have this attribute\n* `null` the attributes doesn't have a value\n* everything else is a the value of the attribute\n\ne.g. if you use the [jQuery Adapter](https://github.com/dodo/node-dt-jquery) the resulting value is the return value of [jQuery.attr](http://api.jquery.com/attr/).\n\nEmits an `attr` Event.\n\n\n#### tag.text([content, [opts]])\n\n```javascript\ntag.text() // get text of a tag\ntag.text(\"content\") // set text\n```\nSet or Get tag text content.\n\nOptions:\n* `escape`\n* `append`\n\nEmits a `text` and `data` Event.\n\nWhen using an adapter getting text results in the content provided by the adapter.\n\ne.g. if you use the [jQuery Adapter](https://github.com/dodo/node-dt-jquery) the resulting text is the return value of [jQuery.text](http://api.jquery.com/text/).\n\n\n#### tag.raw(html, [opts])\n\n```javascript\ntag.raw(\"<div>notfunny</div>\")\n```\nInsert raw html content into a tag.\n\n\nEmits a `raw` and `data` Event.\n\n\n#### tag.write(data, [opts])\n\n```javascript\nfs = require('fs')\nfs.createReadStream(filename).pipe(tag)\n```\nWrite tag data.\n\nUseful to pipe file content into a tag (as text).\n(dunno what happens if you pipe binary through)\n\nOptions:\n* `escape`\n\nEmits a `data` Event.\n\n\n#### tag.hide()\n\n```javascript\ntag.hide()\n```\nHide a tag.\n\nWhen a tag is hidden, `data` events are omitted.\n\nEmits a `hide` Event.\n\n\n#### tag.show()\n\n```javascript\ntag.show()\n```\nShow a tag.\n\nReverses the effect from `Tag::hide`.\n\nEmits a `show` Event.\n\n\n#### tag.end()\n\n```javascript\ntag.end()\n```\nCloses a tag.\n\nThe `end` event will only appear when all children tags are closed.\n\nThe `close` event gets triggered when the closing part of the tag (`</tag>`) gets emitted.\n\nEmits an `end` and a `close` Event.\n\n---\n\n## events\n\nSome events have special behavior when it comes to where they can be received.\n\nMost events travel up the XML tree, some can be only received on their parents.\n\n### global\n\n```javascript\n['add', 'attr', 'text', 'raw', 'data', 'show', 'hide', 'remove', 'replace', 'close']\n````\nThese events can be received from every single tag.\n\nWhen you listen on a *specific tag* you get these events from the tag you are listening on and from all the children tags (recursive).\n\nWhen you listen on a *builder instance* you get all events from all tags.\n\n### local\n\n```javascript\n['new', 'end']\n```\nThese events can be received from every single tag.\n\nWhen you listen for `new` on a *specific tag* you get 'new' events from only the tag you are listening on and from all its direct children (only 1 level deep).\n\nWhen you listen for `new` on a *builder instance* you get 'new' events for all the tags that are created direclty on the builder.\n\nWhen you listen for `end` on a *specific tag* you get the 'end' event only from the tag you are listening on.\n\nWhen you listen for `end` on a *builder instance* you get the 'end' event when the last tag is closed.\n\n\n## partials\n\nIt's recursive! just add a builder instance to a tag:\n```javascript\nxml = new Builder\nsub = new Builder\nroot = xml.tag('root').add(sub).end()\n```\n\n\n\n[![Build Status](https://secure.travis-ci.org/dodo/node-asyncxml.png)](http://travis-ci.org/dodo/node-asyncxml)\n",
  "_id": "asyncxml@0.4.7",
  "_from": "asyncxml@>= 0.4.5"
}
